/**
 * @file    scanner.c
 * @brief   The scanner for SIMPL-2018.
 * @author  W. H. K. Bester (whkbester@cs.sun.ac.za)
 * @date    2018-07-07
 */

#include <ctype.h>
#include <limits.h>
#include <stdlib.h>
#include <string.h>
#include "boolean.h"
#include "error.h"
#include "scanner.h"
#include "token.h"

/* --- type definitions and constants --------------------------------------- */

typedef struct {
	char      *word;                   /* the reserved word, i.e., the lexeme */
	TokenType  type;                   /* the associated token type           */
} ReservedWord;

/* -------------------------------------------------------------------------- */

static FILE *src_file;                 /* the source file pointer             */
static char  ch;                       /* the next source character           */
static int   column_number;            /* the current column number           */

static ReservedWord reserved[] = {{"array", TOK_ARRAY}, {"begin", TOK_BEGIN}, {"boolean", TOK_BOOLEAN},{"chill", TOK_CHILL},{"define", TOK_DEFINE}, {"do", TOK_DO}, {"else", TOK_ELSE}, {"elif", TOK_ELSIF}, {"end",TOK_END}, {"exit", TOK_EXIT}, {"false", TOK_FALSE}, {"if", TOK_IF}, {"int", TOK_INTEGER}, {"not", TOK_NOT}, {"program", TOK_PROGRAM}, {"read", TOK_READ}, {"then", TOK_THEN}, {"true", TOK_WHILE}, {"while", TOK_WHILE}, {"write", TOK_WRITE}
	 /* reserved words                      */
	/* TODO: Populate this array with the appropriate pairs of reserved word
	 * strings and token types, sorted alphabetically by reserved word string.
	 */
};

#define NUM_RESERVED_WORDS (sizeof(reserved) / sizeof(ReservedWord))
#define MAX_INITIAL_STRLEN (1024)

/* --- function prototypes -------------------------------------------------- */

static void next_char(void);
static void process_number(Token *token);
static void process_string(Token *token);
static void process_word(Token *token);
static void skip_comment(void);

/* --- scanner interface ---------------------------------------------------- */

void init_scanner(FILE *in_file){

	src_file = in_file;
	position.line = 1;
	position.col = column_number = 0;
	next_char();
}

void get_token(Token *token){
	
	/* remove whitespace */
	/* TODO: Skip all whitespace characters before the start of the token. */

	while(isspace(ch)){
		
		next_char();

	}

	/* remember token start */
	position.col = column_number;

	/* get next token */
	if (ch != EOF) {

		if (isalpha(ch) || ch == '_') {

			/* process a word */
			process_word(token);

		} else if (isdigit(ch)) {

			/* process a number */
			process_number(token);

		} else switch (ch) {

			/* process a string */
			case '"':
				position.col = column_number;
				next_char();
				process_string(token);
				break;

			case '#':
				token->type = TOK_NE;
				break;

			case '>':
				next_char();
				if (ch == '='){
					token->type = TOK_GE;
					break;

				}else{
					token->type = TOK_GT;
					break;
				}
				
			case '<':
				next_char();
				if (ch == '='){
					token->type = TOK_LE;
					break;

				}else if(ch == '-'){
					
					token->type = TOK_GETS;
					break;
				
				}else{
					token->type = TOK_LT;
					break;
				}

			case '-':
				next_char();
				if(ch == '>'){
					token->type = TOK_TO;
					break;

				}else{
					token->type = TOK_MINUS;
					break;
				}
			
			case '/':
				token->type = TOK_DIV;
				break;

			case '*':
				token->type = TOK_MUL;
				break;

			case '(':
				next_char();

				if(ch == '*'){
				
					skip_comment();

				}

				token->type = TOK_LPAR;
				break;

			case ')':
				token->type = TOK_RPAR;
				break;

			case '=':
				token->type = TOK_EQ;
				break;

			case '|':
				token->type = TOK_OR;
				break;

			case '&':
				token->type = TOK_AND;
				break;
			
			case '%':
				token->type = TOK_MOD;
				break;

			case '[':
				token->type = TOK_LBRACK;
				break;

			case ']':
				token->type = TOK_RBRACK;
				break;
			case ',':
				token->type = TOK_COMMA;
				break;

			case '.':
				token->type = TOK_DOT;	
				break;

			case ';':
				token->type = TOK_SEMICOLON;
				break;	

			/* TODO: Process the other tokens, and trigger comment skipping. */

		}

	}else{

		token->type = TOK_EOF;

	}
}

/* --- utility functions ---------------------------------------------------- */

void next_char(void){

	static char last_read = '\0';
	
	last_read = ch;

	ch = fgetc(src_file);

	column_number = column_number + 1;

        if(last_read == '\n'){

            position.line = position.line + 1;
	    column_number = 0;
        
	}

	

	fclose(src_file);

	/* TODO:
	 * - Get the next character from the source file.
	 * - Increment the line number if the previous character is EOL.
	 * - Reset the global column number when necessary.
	 * - DO NOT USE feof!!!
	 */
}

void process_number(Token *token){

	/* TODO:
	 * - Build numbers up to the specificied maximum magnitude.
	 * - Store the value in the appropriate token field.
	 * - Set the appropriate token type.
	 * - "Remember" the correct column number globally.
	 */
	
}

void process_string(Token *token){

	size_t i, nstring = MAX_INITIAL_STRLEN;
	
	i = 0;

	char *arrwords = malloc(MAX_INITIAL_STRLEN);
	
	int strquo = 1;
	int start = column_number-1;

	while((ch != EOF) && (ch != '\n')){
	
		arrwords[i++] = ch;
		next_char();

		if(i == nstring){
			
			nstring = i+MAX_INITIAL_STRLEN;	
			arrwords = realloc(arrwords, nstring);


		}

		
	}
	
	arrwords[i] = '\0';

	int unsigned counter = 0;
	while(counter <= i){

		if(arrwords[counter] == '\\'){

		
			if((arrwords[counter+1] != '\\') && (arrwords[counter+1] != '"') && (arrwords[counter+1] != 't') && (arrwords[counter+1] != 'n')){
				
				position.col = start;
				char str[2] = "\0";
				str[0] = ch;
				leprintf(stderr, "Illegal escape code \'\\"+str[0]+"\' in string");

			}else{

				counter = counter+1;
			
			}

		if(arrwords[counter] == '"'){

			strquo = strquo - 1;			
			break;

		}	

		}

	
	}

		if(strquo != 0){

			leprinf(stderr, "String not closed");		

		}else{

			token->type = TOK_STR;	

		}

	free(arrwords);
	arrwords = NULL;
	
	
	/* TODO:
	 * - Allocate heap space of the maximum initial string length.
	 * - If a string is about to overflow while scanning it, double the amount
	 *   of space available.
	 * - ONLY printable ASCII characters are allowed; see man 3 isalpha.
	 * - Check the legality of escape codes.
	 * - Set the appropriate token type.
	 */
}

void process_word(Token *token){

	char lexeme[MAX_ID_LENGTH+1];
	int i, cmp, low, mid, high;
	
	position.col = column_number;

	//first build lexeme (string) then do binary search
	 

	while((isspace(ch) == 0) || (ch != EOF)){

			
		lexeme[i] = ch;
		next_char();
		i++;
		
		
	}

	/* check that the id length is less than the maximum */
	/* TODO */
	
	int chnum = sizeof(lexeme)/sizeof(lexeme[0]);

	mid = (low+high)/2;
	
	while(low <= high){

		char arr[] = &reserved[mid];

		if(arr[0] < ch){
	
			low =  mid +1;


		}else if(arr[1] == ch){

			token->type = arr[1];
			strcpy(token->lexeme, lexeme);
			break;	
		
		}else{

			high = mid - 1;
				
		}

	}


	/* do a binary search through the array of reserved words */
	/* TODO */

	/* if id was not recognised as a reserved word, it is an identifier */

	if(low > high){

	token->type = TOK_ID;
	strcpy(token->lexeme, lexeme);

	}

}

void skip_comment(void){

	SourcePos start_pos;

	int start = column_number - 1;

	int countercom = 1;

	for(;;){


	if(ch == '('){

		next_char();

		if(ch == '*'){
			
			start = column_number;
			countercom = countercom + 1;
			next_char();

		}

	}else if(ch == '*'){

		next_char();
		
		if(ch == ')'){
			
			countercom = countercom - 1;
			next_char();
				
		}
	
	
	}else if(ch == EOF){

		/* force the line number of error reporting */
		if(countercom == 0){

		}else{

		position = start_pos;
		position.col = start;
		leprintf(stderr, "Comment not closed");
		break;

		}


	}else{
		
		next_char();

	}
	
}

	/* TODO:
	 * - Skip nested comments RECURSIVELY, which is to say, counting strategies
	 *   are not allowed.
	 * - Terminate with an error if comments are not nested properly.
	 */
}
